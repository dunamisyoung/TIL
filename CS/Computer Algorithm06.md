# 컴퓨터 알고리즘 기초 6강 힙정렬 | T아카데미

---

## 1. 힙 구조

### 힙 정렬 (Heap Sort)

- 힙 구조의 특성을 이용한 정렬
- 수행시간은 합병정렬과 동일한 O(nlgn)
- 삽입 정렬과 동일한 제자리 정렬(Sort in Place)

### 힙의 형태 (The shape of a heap)

- 완전 이진 트리 (Complete binary tree)에 가까운 형태
- 이진 트리(Binary tree)는 각 노드의 자식수가 2이하인 경우
- 완전 이진 트리는 Root 노드부터 Leaf 노드까지 빠짐없이 채워져 있는 트리 및 각노드의 자식수가 최대 2개 인 경우를 뜻한다.
  또한 각 노드는 왼쪽부터 채워져야하는데 이를 만족하지 않는다면 완전 이진트리라고 할 수 없다.
  **트리란? - 부모노드와 자식노드로 이루어진 형태의 그래프를 의미한다.**

### 힙 특성

- 힙 구조를 만족하는 2가지 힙이 존재
  최대힙 특성 - Max-Heap Property
  최소힙 특성 - Min-Heap Property

### 최대힙 특성 (Max-Heap Property) A[parent(i)] ⪰ A[i]

- 부모 노드의 값은 항상 자식노드의 값보다 크다.
- 따라서 전체 트리의 **Root 노드 값이 가장 크다.**
- 또한 각 하위 트리 구조의 Root 노드가 가장 큰 값을 가진다.

### 최소힙 특성 (Min-Heap Property) A[parent(i)] ⪯ A[i]

- 자식 노드의 값은 항상 부모 노드의 값보다 크다.
- 따라서 전체 트리의 **Root 노드 값이 가장 작다.**
- 또한 각 하위 트리 구조의 Root 노드가 가장 작은 값을 가진다.

### 힙의 배열 저장 방식

![saveHeap](https://user-images.githubusercontent.com/66991380/109928758-2098e200-7d09-11eb-83fc-5fd87a51614d.jpg)

- Root 노드는 배열의 첫 번째 A[1] 에 저장
- 각각의 노드들은 레벨별로 저장

힙을 배열에 저장한다면 다음과 같이 검색이 가능하다.

- PARENT(i) return [i/2] - 현재 배열의 인덱스 값을 2로 나누면 부모의 값을 찾을 수 있다.
- LEFT(i) return 2i - 현재 배열의 인덱스 값을 2를 곱해주면 왼쪽 자식의 값을 찾을 수 있다.
- RIGHT(i) return 2i + 1 - 현재 배열의 인덱스 값을 2를 곱해주고 1을 더해주면 오른쪽 자식의 값을 찾을 수 있다.

### 노드의 높이 (Height of Node)

노드의 높이는 현재 노드에서 leaf 노드까지 내려갈 떄 가장 단순하게 내려가는 가장 긴 경로에서 (simple path) 거쳐야 하는 간선의 수이다.

ex ) 위 그림에서 16에서 2까지 몇번 거쳐 내려갔을까? 2, 4, 8 총 3번 거치게 된다.

### 힙의 높이 (Height of Heap)

Root node로 부터 트리의 높이

- θ(lgn)
- Heap은 완전 이진 트리 구조를 가지기에 각 레벨의 노드의 개수가 2배씩 증가하므로 높이는 θ(lgn) - 2\*\*h = n

## 힙 특성 관리(Maintaining the heap property)

### Max-Heapify

노드가 입력으로 주어졌을 때 노드의 좌 우 하위 트리들은 max-heap 특성을 유지하지만, 노드의 값이 하위 트리값보다 작거나 같아서 max-heap 특성을 만족하지 않을때 max-heap 특성이 유지되도록 바꾸는 연산

- 주어진 노드의 값을 '흘러내리게' 해서 주어진 노드와 하위 트리가 max-heap 특성을 가질 수 있도록 변경한다.

4 라는 값이 자식 노드보다 작을 경우 두 자식 중 더 큰 값을 본인과 교체하여서 정렬을 한다.

![heap jpg](https://user-images.githubusercontent.com/66991380/109928692-0eb73f00-7d09-11eb-9be3-e164defcb861.jpg)

전체 수행시간은 O(lgn)
