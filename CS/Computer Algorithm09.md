# 컴퓨터 알고리즘 기초 9강 선형시간 정렬 알고리즘 | T아카데미

---

## 1. 비교정렬의 하한값

### 비교정렬?

**Heapsort, mergesort, Insertion sort, Selection sort, Quicksort**

A라는 수와 B라는 수를 비교해서 큰것은, 오른쪽, 작은것은 왼쪽으로 이동 시키며 정렬하는것이다.

- 비교 연산으로 정렬하는 방법은 아무리 빨라도 Ω (n lg n) 보다 느리다.

## 2. 계수정렬 알고리즘

### 계수 정렬(Counting sort)

- 무엇을 이용하여 정렬하나?
- 계수를 이용해서 정렬 : 실제 숫자를 세는 방법으로 숫자가 몇개인지를 기록 한다.
- 조건에 부합하는 숫자가 몇개가 있는지를 세어보면, 정렬을 할수있다.
- ex) n개의 숫자가 들어왔을때, i번째 숫자가 어디에 위치해야 하나 라고 생각해보면 i 보다 작은수가 몇개인지 카운트 해서 정렬을 하는 방식이다.

![calculation01](https://user-images.githubusercontent.com/66991380/110301930-0712d580-803c-11eb-985a-dd6419076455.jpg)

배열 A가 있고, 그에따라 A 배열에 어떠한 공통된 원소들이 존재하는지 새어주는 C라는 배열이있다.

1. 입력된 배열 A에 가장 작은수와 가장 큰수가 무엇인지 확인한다.
2. Min : 0 / Max : 5 - 그에따라 C라는 배열의 크기와 들어갈 원소를 나열한다.
3. 각각의 숫자대로 C 배열에 작은수부터 큰수대로 기록한다.

![calculation02](https://user-images.githubusercontent.com/66991380/110301935-08440280-803c-11eb-8f1a-b64d38d6deef.jpg)

```jsx
B[(0, 0, 2, 2, 3, 3, 3, 5)];
```

각 원소의 갯수대로 정렬된 배열인 C 배열을 활용해 정렬된 B배열을 만든다.

### 계수 정렬의 특징

- 입력 배열의 순서가 정렬후에도 유지된다. → "stable 하다." 라고한다.

![calculation03](https://user-images.githubusercontent.com/66991380/110301937-08440280-803c-11eb-9e3a-8041970b58a8.jpg)

- 정렬 방식은 A 배열을 입력 받았을때, c'배열은 각 숫자별 원소의 갯수를 누적시켜서 배열을 완성한다. 그리고는 B배열에 A배열의 가장 마지막 인덱스에 있는 수부터 c'을 보고 B배열에 정렬한다.
- c' 배열은 - A배열에서 숫자 0이 2개이고, 숫자1은 A 배열에 없으니 숫자 0의 개수인 2라는 값을 누적해서 가지고, 숫자 2는 앞서 숫자 1에 누적되어 있던 2와 숫자 2의 갯수인 2를 더해 4가되고, 숫자 3은 A배열에서 3개있으니 앞서있던 4와 더해 7이되고, 숫자4는 A 배열에 없으니 누적된 값인 7을 가지고, 숫자 5는 1개있으니 앞서있던 7과 더해 8이되는 방식이다.

계산 방식은 이러하다.

A 배열의 마지막 인덱스에 위치해있는 원소부터 첫째 인덱스 까지 차례대로 B 배열에 정렬시키면 되는데, 먼저 A 배열을 보면 숫자 3이 마지막 인덱스에 위치한다. 그러므로 c' 배열에서 숫자 3이 위치한 곳은 7번째 라고 나오니 B 배열의 7번째 인덱스에 숫자 7을 넣어주며, 숫자 3의 갯수가 -1처리되어 c' 배열에서 6이된다.

다음으로 A배열의 7번째 인덱스의 수를 보니 숫자 0이 위치하고, 그에따라 c'배열을 보니 2번째 인덱스를 나타낸다. B배열의 2번째 인덱스에 숫자 0을 넣고 숫자 0의 갯수가 -1처리되어 1이된다.

그 다음으로 A배열에서 6번째 인덱스의 수를 보니 숫자 3이 위치하고, 그에따라 c'배열을 보니 6번째 인덱스를 나타낸다. B배열의 6번쨰 인덱스에 숫자 3을 넣고 숫자 3의 갯수가 -1처리되어 5가된다.

••• 이런식으로 계속해서 B 배열을 완성하면된다.

![calculation04](https://user-images.githubusercontent.com/66991380/110301939-08dc9900-803c-11eb-98cd-7f2c63f00c8b.jpg)

### 수행시간

전체 수행시간은 θ(k+n)

- k는 입력되는 정수의 범위이다.
- 만약 k=O(n)라면, 수행시간은 θ(n)이 된다.

### 기수정렬 (Radix sort)

- 기수정렬의 예 (MSB → LSB) : 큰자리 수부터 작은자리수로 이동
- 기수정렬의 예 (LSB → MSB) : 작은자리 수부터 큰자리수로 이동
  **일의자릿수 정렬 → 10의 자릿수 정렬 → 100의 자릿수 정렬**

단, 값이 동일할경우 순서는 기존의 정렬되어있던 순서대로 정렬한다.
ex) 1의 자릿수 비교 835,435 ⇒ 835,435
ex) 10의 자릿수 비교 704,608 ⇒ 704,608

![cardinal](https://user-images.githubusercontent.com/66991380/110301941-09752f80-803c-11eb-9059-01cc61b53209.jpg)

### 정리

기존에 배웠던 퀵정렬, 힙정렬, 삽입정렬같은 경우는 두숫자를 비교해서 서로 크냐 작냐를 비교해서 정렬을 하는것이 었다고 한다면, 계수정렬과 기수정렬은 숫자가 몇개인지를 세어보거나 각숫자의 자릿수 끼리 비교해보는 방법을 통해서, 선형시간안에 정렬시킬수있는 알고리즘이다.
