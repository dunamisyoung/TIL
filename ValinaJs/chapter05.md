# 🎈5. 표현식과 문 part arrangement

## 🔎값

**값(value)은 식(표현식, expression)이 평가(evaluate)되어 생성된 결과를 말한다.**
평가란 식을 해석해서 값을 생성하거나 참조하는것을 의미한다.

```JAVASCRIPT
20 + 30; // 50

// `20 + 30`은 자바스크립트 엔진에 의해 평가되어 50이라는 결과를 가지게된다.
```

모든 값은 데이터 타입을 가지며, 메모리에 2진수, 즉 비트(bit)의 나열로 저장된다.

`변수`파트에서 살펴본것처럼 변수는 `하나의 값`을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인이름이라고 했다. 따라서 변수에 할당되는 것은 `값`이다.

```JAVASCRIPT
var sum = 20 + 30;
```

위 코드를 보면 sum 이라는 변수에 **20 + 30이 할당되는것처럼 보이는데**, 사실은 자바스크립트 엔진에의해 20 + 30 의 **연산결과인 숫자값50 이 메모리공간에 저장**된다.

따라서 20 + 30은 변수에 할당되기전에 평가되어 값을 생성해야한다.

## 📌리터럴

위에서 값이 무엇인지에 대해서 알아보았다.

값을 생성하는 방법은 여러가지인데 그중에 가장 기본적인 방법은 리터럴을 사용하는것이다.

**리터럴은 사람이 이해할 수 있는 `문자,숫자,약속된기호`를 사용해서 값을 생성하는 표기방식이다.**

즉, 자바스크립트 엔진에 사람이 이해 할수있는 아라비아 숫자 17을 입력하면 이를 평가해서 숫자값 17을 생성하는 것을 말한다.

즉, 값을 생성하기 위해 미리 약속한 표기법 이라고 할수 있다.

리터럴은 다양한 종류의 값을 생성할수 있다.

- **정수 리터럴** // 100
- **부동소수점 리터럴** // 10.5
- **2진수 리터럴(0b로 시작)** // 0b01000001
- **8진수 리터럴(0o로 시작 ES6에서 도입)** // 0o101
- **16진수 리터럴(0x로 시작 ES6에서 도입)** // 0x41
- **문자열 리터럴** // 'fastcampus'
- **불리언 리터럴** // true false
- **null 리터럴** // null
- **undefined** 리터럴 // undefined
- **객체 리터럴** // {name : 'lee', address : 'Guri'}
- **배열 리터럴** // {1,2,3}
- **함수 리터럴** // function() {}
- **정규표현식 리터럴** // /[A-Z]+/g

## 💡표현식

**표현식은 값으로 평가될수 있는 문**을 뜻한다. 즉, 표현식이 평가되면 <u>새로운 값을 생성하거나, 기존값을 참조</u>한다.

```javascript
var result = 200;
```

위 예제의 200은 리터럴이다. 리터럴 200 은 자바스크립트 엔진에 의해 **평가되어 값을 생성**하므로 리터럴은 그자체로 `표현식`이다.

```javascript
var plus = 100 + 100;
```

100 + 100은 리터럴과 연산자로 이루어져있다. 100 + 100도 **평가되어 숫자값 200을 생성**하므로 `표현식`이다.

```javascript
plus;
```

위에서 만들어 놓은 plus라는 변수 식별자에는 200 이라는 **값**이 들어가있다.
변수 식별자인 plus를 참조하면 자바스크립트 엔진은 **변수 값으로 평가**한다.
식별자 참조는 값을 생성하지는 않지만 **값으로 평가**하므로 `표현식`이다.
이처럼 표현식은 리터럴, 식별자(변수, 함수 등의 이름) 연산자, 함수 호출 등의 조합으로 이루어질수 있으며, 자바스크립트 엔진에 의해서 **값으로 평가되는 모든 문**은 `표현식`이다.

표현식과 값의 관계는 `동치`이다. 이말은 즉, `1+2`를 평가해서 값 `3`이 나오는 과정을 생각해보면, 자바스크립트 엔진은 `1+2라는 표현식`을 `3이라는 값` 과 **동일하게 생각**한다. 따라서 표현식도 값처럼 사용할수 있으며, 문법적으로 **값이 위치할수있는곳에 표현식이 존재할수 있다는 것을 의미**한다.

또한 **표현식은 다른 표현식의 일부가 되어 새로운 값을 만들수있다.**

```javascript
var sum = 10 + 20;

sum + 20;
```

위 코드를 살펴보면
첫번째로 `10 + 20` 이라는 **표현식**을 통해 자바스크립트엔진에 평가받아 생성된 **30 이라는 숫자값**이 런타임 시점에 sum이라는 변수 식별자에 할당되고, 두번째로, sum이라는 변수 식별자를 참조해 **20이라는 숫자리터럴과 더하기 연산**을 하면 **50이라는 새로운 숫자값을 생성**할 수 있다.

## ⌛문

**문(statement)은 프로그램을 구성하는 기본단위이자 최소 실행단위이다.**
문은 여러개의 토큰(token)으로 구성되며 **토큰은 문법상으로 더이상 나눌수 없는 코드의 기본 요소를 의미한다.**

문은 **명령문**이라고도 불리우는데, **컴퓨터에게 내리는 명령**이다. 즉 문이 실행되면 명령이 실행되고 어떤일이든 일어난다.

대표적인 문은 **선언문**, **할당문**, **반복문** 등으로 구분할수있다.
변수 선언문을 실행하면 변수가 선언되고, 할당문을 실행하면 값이 할당되며 조건문을 실행하면 조건에 따라 코드블록이 실행되고, 반복문을 실행하면 특정 코드 블록이 반복 실행된다.

```javascript
//변수 선언문
var num;

//표현식 문(할당문)
num = 12;

//함수 선언문
function current() {}

//조건문
if (num > 1) {
  console.log(num);
}

//반복문
for (var num = 0; num < 2; num++) {
  console.log(num);
}
```

## 📎 세미콜론과 세미콜론 자동 삽입기능

**세미콜론(;)은 문의 종료를 나타낸다.** 즉 자바스크립트엔진은 세미콜론으로 **문이 종료한 위치를 파악**하고, 순차적으로 하나씩 문을 실행한다.

즉, 문(명령문)을 끝낼때는 세미 콜론을 붙여야하는데, 단 **0개이상의 문을 중괄호로 묶은 코드블록({...}) 뒤에는 세미콜론을 붙이지 않아야한다.** 예를 들자면 <u>if문이나, for문, 함수 등</u> 이러한 코드블록들은 언제나 문의 종료를 의미하는 **자체 종결성(self closing)을** 갖기 때문이다.

세미콜론은 생략이 가능하다. 이유는 자바스크립트 엔진이 소스코드 평가 과정에서 문의 끝이라고 생각되는 부분에 자동으로 세미콜론을 붙여주는 **세미콜론 자동 삽입 기능(ASI,automatic semicolon insertion)**이 암묵적으로 수행되기 때문이다.

하지만 세미콜론을 붙이지 않는다면 코드표 내에서 예상하지 못한결과를 도출할 가능성이있기 때문에 붙여서 사용하는것이 좋다고 판단된다.

## 🔨표현식인 문과 표현식이 아닌문

표현식은 문의 일부분일 수도 있고 그자체로 문이 될수도 있다.

**표현식인 문과 표현식이 아닌문을 구별하는 방법은 변수에 할당해 보는것이다.**
표현식인 문은 값으로 평가되기에 변수에 할당할수 있고, 표현식이 아닌문은 값으로 평가할 수 없으므로 변수에 할당하면 에러를 발생시키기 때문이다.

표현식이 아닌 문은 값처럼 사용할 수 없다.

```javascript
var fast = var campus; // SyntaxError : Unexpected token var
```

**💻완료값**
크롬 개발자 도구에서 **표현식이 아닌 문은 실행**하면 언제나 **undefined를 출력**한다.이를 완료값이라고 하며, 완료 값은 표현식의 결과가 아니다. 따라서 다른 값과 같이 변수에 할당할 수 없고 참조할 수도 없다.

즉, **표현식인문은 평가된 값을 반환**하는데, 이것을 통해서도 간단한 표현식인문(값으로 평가될수있는문)인지 아닌지(값으로 평가될수없는문) 간단한테스트도 할 수 있을것이다.
