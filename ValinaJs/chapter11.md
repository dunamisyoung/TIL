# 11. 원시값과 객체의 비교 part arrangement

자바스크립트가 제공하는 7가지 데이터타입은 크게 객체 타입과, 원시타입 (숫자, 문자열, 불리언, null, undefined, symbol) 으로 분류가 가능하다.

이렇게 데이터 타입을 구분하는 이유에 대해서 살펴보면, 아래와 같다.

- 원시 타입의값은 변경불가능한 값(immatable value)이고, 객체 타입의값은 변경가능한 값(matable value)이다.
- **원시값을 변수에 할당하면 변수에 실제 값이 저장(깊은복사) 되지만, 객체를 변수에 할당하면 참조값이 전달된다(얕은복사).**
- 원시값을 갖는 변수를 다른 변수에 할당하면 **원본의 원시값이 복사되어 전달**되고 이를 값에의한 전달이라고 부른다.
  객체는 객체를 가르키는 변수를 다른 변수에 할당하면 **참조값이 복사되어 전달**된다. 이를 참조에의한 전달이라 부른다.

## 원시값이란?

### 1.1 변경 불가능한 값

원시 타입의 값은 변경불가능한 값이다.

값을 변경할수 없다는것이 무엇일까? 먼저 변수와 값을 구분해서 생각해보자. [변수](https://github.com/dunamisyoung/TIL/blob/master/ValinaJs/chapter04.md)는 하나의 값을 저장하기위한 메모리공간 자체 혹은 그것을 가리키는 식별자를 의미하고, 값은 표현식이 평가되어 생성된 결과이다.

이처럼 값을 변경할수 없다는것은 원시값자체에 대한 설명이지 변수에 관한말이 아니다.

원시값을 담기위해 자바스크립트엔진은 원시값에 맞는 메모리 공간을 확보하고, 그에따라 원시값 1개를 할당한다. 이처럼 원시값은 하나의 메모리셀 안에 담기는 값이고,

만약 그 값을 변경하려고 했을때 즉, 재할당하려고 했을떄는 다른 메모리 셀에 재할당 하려는 값을 저장하고, 기존에 변수 식별자가 가르키고 있던 메모리 셀의 주소가 옮겨지는 것이다.

아래 그림을 통해 확인해보자.

![Untitled](https://user-images.githubusercontent.com/66991380/102008349-0d622000-3d73-11eb-8680-243ac8cde68c.png)

_poiemaWeb이미지참조_

이처럼 변수가 참조하던 메모리 공간의 주소가 변경된 이유는 **원시값이 변경불가능한 값이기 떄문**이다. 이러한 특징을 불변성(immutability) 라고 말한다. 불변성을 가지는 원시값을 할당한 변수는 재할당 이외에 변수의 값을 변경할수 없다.

### 1.2 문자열과 불변성

원시값을 저장하려면 확보해야 하는 메모리 공간의 크기를 결정해야한다. 이를 위해 원시타입별로 메모리 공간의 크기가 문자열(2byte) 숫자(8byte) 처럼 미리 정해져 있지만 vendor사 별로 조금씩 차이가 있다.

문자열은 다른 원시값과 조금다른 특징이있다.

문자열은 0개이상의 문자열로 이루어진 집합을 말하며, 1개의 문자는 2byte 메모리에 저장된다. 따라서 문자열은 몇개의 문자로 이루어 졌느냐에 따라 필요한 메모리 공간의 크기가 결정된다.

숫자값은 1도 1000000도 동일하게 8byte의 메모리가 필요하다.

```javascript
var str = 'Hello';
str = 'world';
```

위와같은 문자열을 자바스크립트엔진이 읽어올때는 메모리공간의 첫번째 셀주소를 가르킨다. 두번째 문이 실행되면 새로운 메모리셀을 생성하고 str 이라는 식별자를 `'world'` 라는 문자열 값이있는 주소로 옮긴다.

자바스크립트의 문자열은 **유사배열 객체** 이면서 **이터러블** 이므로 \*\*\*\*배열과 유사하게 문자에 접근할 수 있다.

유사배열객체란? **배열의 인덱스 처럼 프로퍼티 값에 접근할수있으며, length 프로퍼티를 가지는 객체를 의미**한다. 문자열은 마치배열처럼 인덱스를 통해 각 문자에 접근할 수있다. 이는 원시값을 객체처럼 사용할때 래퍼 객체로 자동변환 하는데 이는 나중에 좀더 자세히 알아보자.

```jsx
var str = 'string';

// 문자열은 유사배열 객체이므로 인덱스를 사용해 각 문자에 접근이 가능하다.
str[0] = 'S';
// 하지만 문자열은 원시값이므로 변경이 불가능하다. 이때 에러는 따로 발생하지 않는다.
console.log(str); // string
```

### 1.3 값에 의한 전달

```jsx
var score = 80;
var copy = score;

console.log(score); // 80
console.log(copy); // 80

score = 100;

console.log(score); // 100
console.log(copy); // ?
```

위 score 변수에 숫자 80을 할당하고 그 변수에 새로운 숫자100을 할당했다. copy의 값은 어떻게 될까?

자바스크립트 엔진은 score변수가 가지고 있던 숫자값 80과 동일한 값을 새로 메모리에 만들어 copy변수에 할당하였다.

즉, score변수와, copy 변수는 서로 각자 다른 메모리셀에 다른 값을 가지고 있기에 copy의 값은 score의 변수의 재할당과는 관련이 없다. 즉 copy의 값은 80이라는 숫자값을 가지게된다.

이렇게 원시값을 복사하여 전달하는것을 **얕은복사**라고도 하며, **값에의한전달**이라고도 부른다.

![Untitled2 jpg](https://user-images.githubusercontent.com/66991380/102008406-78135b80-3d73-11eb-9b3a-43aa9dec3650.jpg)
_poiemaWeb이미지참조_

사실 값에의한 전달도, 값을 전달하는것이 아닌 메모리 주소를 전달 하는 것이다. 단 메모리 주소를 통해 메모리 공간에 접근했을떄 값을 취득할수 있다.

**가장중요한 사실은 원시값을 복사해서 다른 변수에 전달했을때 서로다른 메모리 공간에 저장되어 어느 한쪽에서 값을 변경하였어도 영향을 주지않는다는점이다.**

## 2. 객체

객체는 프로퍼티 개수가 정해져있지 않고 동적 추가와 삭제가 가능하다. 즉, 객체는 원시값 처럼 메모리 공간의 크기를 정해둘수 없다.

객체는 원시값과 다른 방식으로 동작하도록 설계되어있다. 원시값과 비교하며 객체를 살펴보자

### 2.1 변경 가능한 값

변경가능한 값(mutable value)인 객체를 변수에 할당해보자.

```jsx
var person = {
  name: 'Lee',
};
```

원시값을 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 원시값에 접근할수 있다. 하지만 **객체는 변수가 기억하는 메모리 주소에 접근하면 참조값에 접근**하게된다. 참조값은 객체가 저장된 메모리 공간의 주소 그자체 라고 할 수 있다.

![Untitled3](https://user-images.githubusercontent.com/66991380/102008414-895c6800-3d73-11eb-8941-e30f975c8992.jpg)

_poiemaWeb이미지참조_

이처럼 객체에 접근하면 참조값이 나오고 그 참조값을 통해 접근하면 객체에 프로퍼티에 접근할수 있다. 즉, 객체를 할당한 변수를 참조하면 메모리에 저장되어있는 객체 프로퍼티에 접근할수 있다.

원시값은 변경 불가한 값이므로 원시값을 갖는 변수의 값을 할당하려면 재할당 말고는 방법이 없지만, 객체를 할당한 변수는 재할당없이 참조값을 통해 접근해 객체의 변경이 가능하다.

```jsx
var person = {
  name: 'Lee',
};

// 프로퍼티 값 갱신
person.name = 'Kim';

// 프로퍼티 동적 생성
person.address = 'Seoul';

console.log(person); // {name: "Kim", address: "Seoul"}
```

객체를 할당한 변수는 이렇게 유연하게 동작하게되는데 이런 유연함 떄문에 생기는 부작용이있다. 이는 여러개의 식별자가 하나의 객체를 공유할수 있다는것인데, 이것을 통해 값의 보존이 어려워진다.

객체에서의 얕은복사와 깊은 복사에 대해 알아보면 객체를 프로퍼티 값으로 갖는 객체의 경우 얕은 복사는 한단계 까지만 복사하는것을 의미하고 깊은 복사는 객체에 중첩되어있는 객체까지 모두 복사하는 것을 말한다.

```jsx
const foo = {
  a: {
    b: 2,
  },
  f() {},
};

// 얕은 복사
let c = { ...foo };
c = Object.assign({}, foo);

// JSON.parse 와 JSON.stringify를 사용한 깊은 복사
c = JSON.parse(JSON.stringify(o));

// lodash의 cloneDeep을 사용한 깊은 복사
// "npm install lodash"로 lodash를 설치한 후, Node.js 환경에서 실행
const _ = require('lodash');

c = _.cloneDeep(foo);
```

얕은 복사와 깊은복사로 생성된 객체는 원본과는 다른객체이다. 즉, 원본과 복사본은 참조값이 다른 별개의 객체다. 하지만 얕은 복사는 객체에 중첩되어있는 객체의 경우 참조값을 복사하고 깊은 복사는 객체에 중첩되어있는 객체까지 모두 복사해서 원시값처럼 완전한 복사본을 만든가든 차이가 있다.

원시값을 할당한 변수를 다른 변수에 할당하는것을 **깊은복사**, 객체를 할당한 변수를 다른 변수에 할다하는 것을 **얕은 복사**라고 부르는 경우도 있다.

```jsx
const v = 1;

// "깊은 복사"라고 부르기도 한다.
const c1 = v;
console.log(c1 === v); // true

const o = { x: 1 };

// "얕은 복사"라고 부르기도 한다.
const c2 = o;
console.log(c2 === o); // true
```

### 2.2 참조에 의한 전달

여러개의 식별자가 하나의 객체를 공유할 수 있다는 것이 어떤 부작용을 불러오는지 확인해보자.

```jsx
var person = {
  name: 'Lee',
};

// 참조값을 복사(얕은 복사)
var copy = person;
```

위처럼 person변수의 참조값이 copy에 전달됬다. 이것을 **참조에 의한 전달**이라고한다.

_poiemaWeb이미지참조_

![Untitled4](https://user-images.githubusercontent.com/66991380/102008420-9b3e0b00-3d73-11eb-9cca-82816e12917a.jpg)

위 그림을 참고해보자. 위 그림처럼 person변수에 할당되있는 객체의 참조값을 copy변수에 전달했을때 같은 객체에 접근이 가능하게 된다. 이를 통해 어느 한쪽에서 프로퍼티 값을 변경하거나, 추가, 삭제 했을경우 서로 영향을 주게된다.

값에 의한 전달과 참조에 의한 전달은 식별자가 기억하는 메모리공간에 저장되어있는 "**값(참조값, 원시값) 을 복사해서 전달"** 하는 면에 동일하기에 자바스크립트는 값에의한 전달만이 존재한다고할수있다.
