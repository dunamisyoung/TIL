# 🎈12. 함수 part arrangement

## 🔎 함수란?

자바스크립트에서 가장 중요한 개념이라고 할 수있다.
함수는 **입력을 받아서 출력을 내보내는 일련의 과정을 코드블록으로 감싸 하나의 실행 단위로 정의**한 것이다.

함수는 객체이며 값으로 취급된다. 즉, 변수에 담을수있다는 뜻이기도하다.
함수의 이름은 줄수도 있고 주지 않을수도 있다.

```javascript
// 함수의 생김새
function add(x, y) /*<-매개변수(x,y)*/ {
  return /*<-반환문*/ x + y;
}

add(2, 5); /*<-인수(2,5)*/
```

위 코드에서 매개변수 앞에있는 add는 함수이름이라고 불리우는 식별자이다.
인수(Argument)는 입력되는 값이고,매개변수(Parameter)는 입력값을 받아드리는 변수이다.
return은 키워드이며 함수 안에 코드블록을 실행후에 출력값을 반환 해주는 반환값이다.

## 💡 함수의 사용 이유

함수는 왜 사용하는가?

```javascript
var x = 0;
var y = 0;
var result = 0;

x = 1;
y = 2;
result = x + y; //3

x = 3;
y = 4;
result = x + y; //7
```

위코드에서 불편한 점은 중복이 많다는것, 그리고 수정시에 일일이 하나하나 수정해야하는 번거로움이있다. 실수를 줄이기위해서, 시간적인 측면과 가독성을 위해서 함수를 사용해야하는 이유이다.

- 함수를 사용하면 **수정이 간편하다는 장점**이 있고, **코드를 반복해서 기재하지 않아도 되는 유지보수 즉, 재사용의 관점에서 좋다.**

함수는 변수이름처럼 이름을 가질수 있다.

함수의 이름을 통해서 이함수가 어떠한 기능을 하는지 다른 개발자들에게 전달할수 있으며, 네이밍의 중요성을 알수있는 좋은 예시이다.

## 📰 함수 리터럴

**함수는 객체 타입의 값이며, 함수도 함수 리터럴로 생성할 수 있다.**
즉, 사람이이해하고 자바스크립트가 이해할수있는 함수의 표기방식을 통해 값을만들수 있는 것이다.

함수는 function키워드, 함수이름, 매개변수목록, 함수 몸체로 구성되어있다.

```javascript
var move = function add(x, y) {
  return x + y;
};
```

함수 리터럴의 구성요소는 이렇게 되어있다.

- **함수이름**

  - 식별자 네이밍 규칙을 준수해야한다.
  - 함수 이름은 함수 몸체 내에서만 참조할수 있는 식별자이다.
  - 함수 이름은 생략이 가능하다. 변수와 마찬가지로 재사용을 위해서 이름을 붙일수 있다.
    함수에 이름이 있는 함수를 기명함수(named function) 함수 이름이 없는 함수를 익명 함수(anonymous function)이라고 한다.

- **매개변수**

  - 0개이상의 매개변수를 소괄호로 감싸고 쉼표로 구분한다.
  - 매개변수에는 함수 함수 호출문의 **인수가 순서대로 할당 된다.**
  - 매개변수는 **함수 몸체 내에서 변수와 동일하게 취급된다.**

- **함수몸체**
  - 함수 몸체는 호출에 의해 실행된다.
  - 함수가 호출되면 함수몸체 안에있는 문들을 실행한다.

**함수는 객체라고 했는데 일반객체는 호출할수 없지만 함수객체는 호출할수있다.**

## 🧮 함수 정의

함수내에서 동작될것들에 관해 미리 정해놓은것을 함수 정의라고 한다.

함수를 정의하는 방법은 4가지가 있다.

- ### 함수 선언문

  ```javascript
  function add(x, y) {
    return x + y;
  }
  ```

  위 코드가 바로 함수 선언문이다.
  함수 선언문과 함수리터럴은 형태가동일하다. 하지만 단하나 다른점은 함수선언문은 함수이름을 빼놓을수 없지만, 함수 리터럴은 생략이 가능하다.

  함수 호출때 사용한 인수들은 매개변수로 전달되어 순서대로 사용된다.

  함수 선언문은 표현식이 아닌문이기에 변수에 할당이 불가하다.

  함수 선언문은 **함수리터럴이 단독으로 사용된다.** 즉, 변수의 우항에 존재하지 않는다 던지 표현식으로 평가되지 않는 문맥에 오게되면, 함수 선언문으로 평가된다.

  함수 선언문이나 함수리터럴은 동일하게 함수 객체를 만든다.
  함수 이름은 함수 몸체안에서 함수 이름을 호출할수 있고 함수몸체 밖에서는 식별자의 참조가 불가능하다고 했는데, 선언문의 경우에는 다르다.

  변수 호이스팅때 변수 식별자는 초기화 단계를 거치며 undefined로 초기화되지만,
  **함수 선언문은 런타임이전에 실행되며 자바스크립트 엔진에의해서 함수이름과 동일한 식별자를 암묵적으로 생성하고 함수 식별자는 초기화 단계를 거치게되는데 함수 객체로 초기화한다.**

- ### 함수 표현식

  ```javascript
  var good = function (x, y) {
    return x + y;
  };

  console.log(good(2, 5));
  ```

  위 코드가 바로 함수 표현식이다.
  **자바스크립트의 함수는 객체 타입의 값으로 일반적인 값처럼 사용할수 있다.**
  함수는 일급 객체이며 값과 동일하게 동작하는 객체를 일급객체라고 부른다.

  **그렇기에 함수 리터럴로 생성한 함수 객체를 변수에 할당할수 있게되는데, 이것을 바로 함수 표현식이라고 부른다.**

  **일반적으로 함수 표현식에서는 함수이름을 붙여주지 않는다.**
  그 이유는 이미 변수 식별자가 함수 객체를 가르키고 있기 때문이다.
  함수 이름이 붙여주는 경우에는 보통 재귀함수로써의 기능을 하고자 할때 사용한다.

  하지만 재귀 함수로 기능을 하고자 할때에도 변수 식별자로 함수몸체에서 호출이 가능하다.
  재귀함수 파트는 조금 더 있다가 살펴보자.

  **함수선언문은 표현식이 아닌문이고, 함수선언문은 표현식인 문이다.**

- ### 함수 생성 시점과 함수 호이스팅

  위 선언문 마지막에 잠깐 설명했지만,
  함수 선언문은 함수 선언문 이전에 함수를 참조할수도 있고 호출할수도있다.
  함수 표현식은 함수 표현식 이전에 참조가 가능하지만 undefined값을 출력한다.

  함수 표현식인 경우에는 함수 호이스팅이 발생하지 않고 변수 호이스팅이 발생한다.

  함수 선언문은 런타임 이전에 자바스크립트 엔진이 실행한다.
  함수 선언문은 함수 호이스팅이 발생하지만 , 함수 표현식은 변수 호이스팅이 발생한다.

  ```javascript
  // 함수 참조
  console.log(add); // f add(x,y)
  console.log(sub); // undefined

  // 함수 호출
  console.log(add(2, 5)); // 7
  console.log(sub(2, 5)); // TypeError: sub is not a function

  // 함수 선언문
  function add(x, y) {
    return x + y;
  }

  //함수 표현식
  var sub = function (x, y) {
    return x - y;
  };

  /* 
  두줄짜리 함수 표현식
  var sub ; 
  
  sub = function (x,y){
    return x - y;
  }
  */
  ```

  함수 표현식은 변수 선언문과 변수 할당문으로 이루어져있다.

- ### Function 생성자 함수

  ```javascript
  var add = new Function('x', 'y', 'return x + y');
  ```

  위코드가 바로 Function 생성자함수이다.

  지금껏 우리는 함수 리터럴을 이용해서 함수를 생성해 왔는데 Function 키워드로도 함수 객체를 생성할 수 있다.

  매개 변수의 목록과 함수 몸체를 전달해서 new Function 함수를 변수 식별자에 할당 할 수 있다.

  Function 생성자 함수를 사용하여 만든 생성자 함수는 클로저를 생성하지 않고, 기존함수 생성과는 다른 동작을 하게된다. 그렇기에 권장하지 않는다.

- ### 화살표 함수

  ```javascript
  const add = (x, y) => x + y;
  console.log(add(2, 5));
  ```

  ES6부터 생긴 화살표함수는 function 키워드 대신에 `=>` 를 사용하여 보다 간략한 방법으로 함수를 선언하는것이다.

  우리가 알고 있는 함수는 안에 많은 기능들을 가지고 있었지만 **함수 본연의 기능만을 가지고 있는 경량화된 함수를 만든것이 화살표함수이다.**

  생성자 함수로 사용할수 없으며, 프로토 타입이라는 프로퍼티를 가지고 있지 않다.

  나중에 자세하게 배우자.

## 📞 함수 호출

**함수 선언문은 함수 호이스팅이 발생하고, 함수 표현식은 변수 호이스팅이 발생한다.**

함수를 호출하면 **코드 실행 흐름이 중단되고 함수 내부로 실행 흐름이 옮겨진다.**

- ### 매개변수와 인수

  함수 외부에 있는 값을 함수 내부로 전달할때 그 값을 인수라고하며, 인수를 전달받는 창구가 바로 매개 변수이다.

  매개 변수는 Parameter 또는 인자라고 불리우며, 인수는 Argument라고 불린다.

  일반적인 경우는 매개변수의 갯수와 인수의 갯수가 동일해야한다.
  외부에서 함수내부로 전달하는 값 자체를 인수라고 부른다.
  **인수는 매개변수에 순서대로 할당되어진다.**

  **매개 변수가 변수이기때문에, 인수에는 값이 와야한다.**
  왜냐하면 변수에 담길수 있는것은 값으로 평가되는 표현식 이어야 하기때문이다.

  함수에서 매개변수는 선언이라는 키워드(var, let, const) 없이 사용되며 변수선언의 의미를 가진다.

  함수가 호출되어지면 소스코드가 **런타임 이전에 매개변수가 먼저 생성된다. 그리고 undefined로 초기화 된다. 인수에 의해 할당이 이루어지면 할당값을 부여받는다.**

  **함수 몸체외부에서 함수 스코프에 의해서 매개변수를 호출할수없다.**

  **매개변수의 갯수와 인수의 갯수가 달라도 에러가 발생하지 **않는다.
  인수가 매개 변수의 개수보다 작다면 **할당받지 못한 값에는 undefined로 초기화가 되어있는 상태로 남아있게된다.**

  매개 변수의 값보다 인수의 값이 많다면 함수 객체에서 유요한 객체로 인수의 값을 저장하는 arguments 객체안으로 들어간다.

  인수가 몇개인지 알수 없는 함수는 가변인자 함수라고 부른다.

- ### 인수 확인

  자바스크립트는 매개변수의 갯수와 인수의 갯수를 체크하지 않는다.

  자바스크립트의 변수는 정적타입언어가 아니고, 동적타입언어이다. 인수의 타입의 정보를 알수가없다.

  **자바스크립트 에서는 매개변수를 지정한 경우에는 인수의 타입과 갯수를 알아야할 필요가 있을수 있다.**

  적절한 인수가 전달되었는지의 확인이 필요하다.

  자바스크립트는 동적타입언어이고 ,**매개변수와 인수의 갯수가 맞아떨어지는지 체크하지 않기때문에 매개변수에 우리가 기대하는 타입의 인수를 체크해볼필요가 있다.**

- ### 매개 변수의 최대 개수

  함수를 정의할때 매개변수의 갯수는 최대 몇개까지 정하는 것이 좋을까? 매개변수는 순서에 의미가 있다. **매개변수의 갯수가 많으면 많을수록 순서를 신경써서 코드작성을 해야하니 불편하다.**

  매개변수는 적으면 적을수록좋다. 함수가 하나의 일만을 하도록 만드는것이 이상적이며, 함수몸체가 짧은것이 좋다.

  **많아 봐야 3개 이상을 넘지 않는것이 좋으며, 그 이상의 매개변수가 필요하다면, 객체로 할당 받는것이 좋다.**

  객체는 순서에 의미가 없고 프로퍼티 키에 의미가 있기에 값이 의미하는 바를 정확히 알수 있다.

  **원시값에 경우에는 값이 복사되어 전달되고 객체는 참조값이 복사되어 전달된다.**

- ### 반환문

  함수는 return 키워드와 반환값으로 이루어져 있으며, 함수호출문이 소스코드를 평가한 값이 반환값으로 평가되어진다.

  **함수호출문도 자바스크립트엔진에 의해 값으로 평가되기에 표현식이다.**

  반환문의 두가지 역할은?
  **함수의 실행을 중단하는 역할이 있다. 즉, 반환문 이후에 등장하는 문은 실행되지 않는다.**

  반환값을 함수 호출문에 반환값을 반환하는 역할을한다.

  **함수 몸체내에서 반환값으로 사용할 표현식을 생략하게되면 암묵적으로 undefined가 반환된다.**

  return키워드와 반환값 사이에 줄바꿈을 하게되면 return뒤에 암묵적으로 ASI가 세미콜론을 붙여주게된다. 그렇기에 반환문으로 평가한다.

## 📩 참조에 의한 전달과 외부 상태의 변경

원시값은 값에의한 전달방식으로 동작하고 객체는 참조에 의한 전달 방식으로 동작한다.

매개 변수는 인수의 타입에따라 값에의한전달, 타입에 의한 전달로 동작한다.

함수 외부에서 인수를 통해 원시값을 전달하게 되면, 함수 밖에있는 값과 함수 내부에 있는 값은 다른 메모리 공간에 저장된 별개의 값이된다.

객체가 할당되어진 상태라면 말은다르다. 식별자가 가르키고 있는 참조값이 복사되어 매개변수에 전달되기에 같은 메모리 셀에담긴 값을 바라보게된다.

원시값을 할당한 변수를 매개변수를 통해 함수 내부로 전달했을경우에 원시값을 가지고 있는 변수가 값에의한 전달 방식으로 동작하므로 2개의 다른 값은 전혀 다른값이다.

객체를 할당하고 있는 변수를 매개변수를 통해 함수 내부로 전달했을 경우에는 참조값이 복사되어 전달되어 함수 외부와, 함수내부의 바라보는 객체가 동일하게됨으로 어느 한쪽에서 변경을하게되면 같이 값이 변경된다.

이런식으로 코딩하게되면 코딩의 복잡성이 증가된다..

객체를 원시값처럼 사용하면 된다.
부수효과를 최대한 억제하도록 노력해야한다.

**부가적으로 참조값이 전달되는것을 얕은복사(객체의 참조값전달),
깊은복사는 값자체(원시값전달), 데이터가 전달되는것을 의미한다.**

## 🔮 다양한 함수의 형태

- ### 즉시 실행 함수

  ```javascript
  // 익명 즉시 실행함수
  (function () {
    var a = 3;
    var b = 5;
    return a * b;
  })();

  // 기명 즉시 실행함수
  (function num() {
    var a = 3;
    var b = 5;
    return a * b;
  })();

  num(); // ReferenceError: num is not defined
  ```

  위와같은 코드를 즉시 실행함수라고 부른다.

  호출연산자`()` 앞에 오는 피연산자는 함수 객체여야한다.

  **즉시 실행 함수란 함수 정의와 동시에 즉시 호출되는 함수 **이다.IIFE 라고 부르기도 하며, 익명함수로 사용되는것이 일반적이다. 하지만 기명 즉시 실행함수도로 실행할 수 있다.

  **소괄호의 의미는 그룹연산자이다.**

  **그룹연산자를 쓰는 이유는 함수 선언문을 그룹연산자를 통해 함수리터럴로 표현시키기 위함이다.** 그룹연산자 안에 오는 함수 선언문은 피연산자의 의미를 가지게 된다.**즉, 그룹연산자 안에는 값으로 평가되는 값들이 와야한다.**

  즉시 실행 함수는 재호출이 불가하여, 코드블록이 한번 실행되고 끝난다.

  재귀 함수를 사용하고자 할때는 기명 즉시 실행함수를 이용해야 한다. 그이유는 스코프파트에서 살펴보도록하자.

  즉시 실행함수는 반드시 그룹연산자로 묶어주어야한다. 그렇지 않으면 오류가 발생한다.

  세미콜론 자동 삽입기능 떄문에 블록문에 끝에 붙여지기 때문이다.

  그룹 연산자를 대체할수 있는것은 function 키워드 앞에 부정 연산자를 사용하는것으로도 가능하다. +,!연산자도 가능하다.

  일반적으로 즉시실행함수도 변수에 담을수 있고, 할당한 변수를 통해서 반환값도 받을수있다.

- ### 재귀 함수

  ```javascript
  function escape(n) {
    if (n < 0) return;
    console.log(n);
    escape(n - 1); // 재귀 호출
  }
  escape(10);
  ```

  **함수가 자기 자신을 호출하는 행위를 재귀함수라고 한다.**
  반복적 연산을 간단하게 구현할수 있다. 보통 팩토리얼을 만들때 사용한다.

  반드시 탈출 조건을 주어서 함수문을 중단시키도록 만들어 주어야한다.
  탈출조건이 없는 재귀 함수는 반복실행된다.

  **함수 표현식으로 재귀함수를 만들때는 함수 이름을 호출하는것도 가능하고 함수 식별자로도 호출이가능하다.**

  재귀함수는 반복문을, 대용하는 것이다.
  함수이름으로 자신이 자신을 호출한다.

  **탈출조건이 없으면 무한루프에 빠진다가 중요하다.**

- ### 중첩 함수

  ```javascript
  function outside() {
    var x = 1;

    // 중첩 함수
    function inside() {
      var y = 2;

      console.log(x + y);
    }

    inside();
  }

  outside();
  ```

  **함수내부에서 정의된 함수를 중첩 함수라고 부른다.**s
  중첩함수는 일반적으로 외부함수를 도와서 코드를 구현하는 헬퍼함수의 역할을한다.

  함수는 문이 위치할수있는곳에서 모두 사용할수있다.

- ### 콜백 함수

  중복되는 기능이 있을때 함수의 갯수를 늘리지 않고 **하나의 함수로 변환되는 부분만 함수 외부에서 함수 내부로 받아들인다면 받아드린 로직을 기존에 만든 함수와 합성한다면??**

  **고차함수에 <u>매개변수를 통해 전달되는 함수를 콜백 함수</u>라고 부른다.**
  **고차함수를 매개변수를 통해 함수를 전달받거나 반환하는경우를 말한다.**

  인수내에서 함수리터럴을 통해 바로 사용할수도있다.

  ```javascript
  add(5, function sub() {
    return x + y;
  });
  ```

  이런경우에는 한번만 함수를 사용한다는것을 의미하는데, 여러번 호출할 일이있다면 **함수표현식을통해 만들어야 함수를 여러번생성하지 않아도된다.**

  콜백함수를 사용할때 주의사항은 고차함수에 전달해야한다.
  **고차함수의 인수 안에 콜백함수의 호출문을 쓰는것이 아닌 함수의 참조를 적어주어야한다.**

- ### 순수 함수와 비순수 함수

  **순수함수 - 부수효과가 없는 함수**
  **비순수함수 - 부수효과가 있는 함수**

  외부 상태를 전달받고 있으나, 외부에 영향을 주지 않는다. 순수함수는 언제나 같은 값을 반환한다. 외부에 의존하지 않는 함수.

  외부상태의 값을 직접 참조한다. 그렇기에 외부에 영향을 준다. 비순수 함수는 외부의 값들을 변경해서 반환한다. 또한 호출할떄 마다 다른 값들을 반환하게된다. 외부상태에 의존하는 함수이다.

  순수함수는 동일한 인수가 전달되면 동일한 반환값을 반환한다.
  비순수함수는 동일한 인수가 전달되면 다른 반환값을 반환한다.

  비순수함수는 변경사항을 파악하기 어렵다.
  함수형 프로그래밍에서는 비순수함수를 지양하고, 순수함수를 지향해야한다.
