# 🎈9. 타입 변환과 단축 평가 part arrangement

## 🔎 타입변환이란?

**자바스크립트의 모든 값은 타입이 있다.**

개발자가 **의도적으로 값의 타입을 변환하는것을 명시적 타입변환**(explicit coercion)또는 **타입 캐스팅**(type casting)이라 한다.

```javascript
var result = 100;
result = '백점';
// 위코드는 명시적 타입변환이 아니다. 이것은 재할당을 의미한다.

var score = 90;
var newScore = score.toString();

console.log(typeof newScore, newScore);
// 이것이 명시적 타입변환이다. 출력하게되면 string, 90이 나오는데 뒤에 있는 90은 숫자값 90이 아니라 문자열 90이다.

console.log(typeof score);
// 기존의 score 90의 값은 변하지 않는다. 그저 새로운 값을 만들어 낸것이다.
```

위의 코드처럼 **개발자가 의도하여서 타입을 변경한것이 아니면 바로 그것이 암묵적 타입 변환이다.**

```javascript
var score = 10;

var newScore = score + '';
console.log(typeof newScore, newScore);
// 숫자값 10과 빈문자열이 더해져 암묵적으로 숫자값 10이 아닌 문자열 10을 만들어 낸다.

console.log(typeof score);
// 기존에 score라는 변수 식별자에 담겨 있던 10이라는 숫자값은 변하지 않았다.
```

**암묵적타입변환**과 **명시적타입변환**을 통해 예제에서 살펴본 score라는 변수에 담긴 **원시값을 변경할수는 없다.**
**원시값은 변경 불가능한 값**이기 때문이다.
타입변환은 <u>**기존의 원시값을 이용해 새로운 원시값을 생성하는것 일뿐이다.**</u>

그렇다면 이렇게 예측하기 힘든 암묵적 타입변환을 도출하는 소스코드는 작성하면 안되는것일까?
옳고 그름을 벗어나 두가지 방법 모두다 **제대로 동작원리를 이해하고 사용하는것에 초점을 두면 좋을것이라고 생각한다.**

## 🕶 암묵적 타입변환

자바스크립트 엔진은 표현식을 평가할때 오류를 최소화 하기위해 개발자의 의도와 다르게 동작한다. 즉, 암묵적으로 데이터 타입을 강제 변환하는경우가있다.

```javascript
// 좌항과 우항의 값이 암묵적으로 타입변환되어 문자열로 해석된다.
'10' + 7; // '107'

// 좌항과 우항의 값이 암묵적으로 타입변환되어 숫자로 해석된다.
10 * '7'; // 70

// boolean 타입으로 변환되어 해석된다.
!1; // false
```

### 📰 문자열 타입으로 변환

```javascript
10 + '7'; // 17
```

위 예제에서의 `+`연산자는 문자열 연결 연산자로 동작하였다.
자바스크립트 엔진은 표현식을 평가하기위해 문자열이 아닌 다른 피연산자의 타입을 암묵적으로 문자열로 변환시킨다.
**문자열 연결연산자의 동작조건은 피연산자중 <u>하나 이상이 문자열 일때 동작</u>한다.**
이뿐만이 아니라 ES6에서 도입된 **탬플릿 리터럴의 표현식 삽입에서도 암묵적으로 타입변환이 이루어진다.**

```javascript
`우리팀의 점수는 ${90 + 7} 점이다.`; //우리팀의 점수는 97점이다.
```

### 🧮 숫자 타입으로 변환

### 🔐 불리언 타입으로 변환

## 👓 명시적 타입변환

### 📰 문자열 타입으로 변환

### 🧮 숫자 타입으로 변환

### 🔐 불리언 타입으로 변환

## 📌 단축평가

### 📕 논리 연산자를 사용한 단축 평가

### 📗 옵셔널 체이닝 연산자

### 📘 null 병합 연산자
